选一个海岛
=========================



.. meta::

   :keywords: 层次分析法, 权衡


选择一个海岛，对我这样选择困难症中期和拖延症晚期的人来说，就像上班准时到一样，总是要偷点懒的。

在吉隆坡转机，有不少东南亚的海岛，听说还不错，但是具体选哪一个呢？ 作为一个啥都了解一点的水货，我要学以致用(开始装逼)了。


步骤

- 新建一个 Google docs，记下海岛选项。
- 抽几个比较关心的维度。(选择维度也有点门道，此处仅玩乐，不作细述。)
- 最好的打 9 分， 最低的打 0 分。
- 得到一个每个岛各个维度的分数。



.. image:: /_static/island_choices.png
	:height: 300px
	:width:  600px


| 如果只是简单的求和，很快就可以得到得分最高的海岛。
| 但不同维度的重要性不同，所以要给每个维度给一个权重。
| 那么如何拍脑袋决定维度的权重呢？

步骤：

- 将11个维度做成一个11x11 的二维矩阵。
- 每个维度两两比较，相同重要 用 1 表示。 A 比 B 重要 用大于 1 (3,5,7,9)的数字表示。不重要的用 1/3, 1/5, 1/7 表示。
- 得到一个如下的二维矩阵。

因为该矩阵是对称的，所以比较的时候，只需要填一半。



.. code-block:: python

    # 因为我懒， 所以相对重要的时候 用 2 表示， 相对不重要的时候 用 1/2 表示 :-) 

	In [10]: matrix
	Out[10]:
	[['1', '2', '2', '1', '1', '1', '1', '1', '1', '2', '2'],
	 ['', '1', '2', '0.5', '1', '2', '2', '2', '1', '1', '0.5'],
	 ['', '', '1', '0.5', '2', '1', '2', '2', '1', '1', '0.5'],
	 ['', '', '', '1', '1', '2', '1', '1', '2', '0.5', '0.5'],
	 ['', '', '', '', '1', '1', '1', '1', '1', '0.5', '0.5'],
	 ['', '', '', '', '', '1', '2', '2', '2', '0.5', '0.5'],
	 ['', '', '', '', '', '', '1', '1', '2', '0.5', '0.5'],
	 ['', '', '', '', '', '', '', '1', '1', '0.5', '0.5'],
	 ['', '', '', '', '', '', '', '', '1', '0.5', '0.5'],
	 ['', '', '', '', '', '', '', '', '', '1', '0.5'],
	 ['', '', '', '', '', '', '', '', '', '', '1']]

   # 简单处理下，把矩阵补全。

	In [24]: for i in range(1,11):
	    ...: 	for j in range(i):
	    ...:	matrix[i][j] = 1/float(matrix[j][i])

   

	In [25]: matrix
	Out[25]:
	array([[1. , 2. , 2. , 1. , 1. , 1. , 1. , 1. , 1. , 2. , 2. ],
	       [0.5, 1. , 2. , 0.5, 1. , 2. , 2. , 2. , 1. , 1. , 0.5],
	       [0.5, 0.5, 1. , 0.5, 2. , 1. , 2. , 2. , 1. , 1. , 0.5],
	       [1. , 2. , 2. , 1. , 1. , 2. , 1. , 1. , 2. , 0.5, 0.5],
	       [1. , 1. , 0.5, 1. , 1. , 1. , 1. , 1. , 1. , 0.5, 0.5],
	       [1. , 0.5, 1. , 0.5, 1. , 1. , 2. , 2. , 2. , 0.5, 0.5],
	       [1. , 0.5, 0.5, 1. , 1. , 0.5, 1. , 1. , 2. , 0.5, 0.5],
	       [1. , 0.5, 0.5, 1. , 1. , 0.5, 1. , 1. , 1. , 0.5, 0.5],
	       [1. , 1. , 1. , 0.5, 1. , 0.5, 0.5, 1. , 1. , 0.5, 0.5],
	       [0.5, 1. , 1. , 2. , 2. , 2. , 2. , 2. , 2. , 1. , 0.5],
	       [0.5, 2. , 2. , 2. , 2. , 2. , 2. , 2. , 2. , 2. , 1. ]])

   # 将上面的矩阵A每一列归一化得到矩阵B；
   # 将矩阵B每一行元素的平均值得到一个一列n行的矩阵C；
   # 矩阵C即为所求权重向量。

   # 上面的操作有点繁琐，我因为懒，也就不展示了。 
   # 有兴趣的同学可以看看 层次分析法： http://wiki.mbalib.com/wiki/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95

	# 每个维度的权重 
	In [96]: n
	Out[96]:
	array([0.71739442, 0.9565259 , 1.07609164, 0.87681541, 1.11594688,
	       1.07609164, 1.23551262, 1.27536786, 1.27536786, 0.79710491,
	       0.59782869])

   




得到各个维度的权重之后，将分数矩阵和权重向量的乘积就是每个岛的加权后的得分了。


.. code-block:: python

	In [95]: m
	Out[95]:
	[[6, 6, 0, 9, 2],
	 [9, 9, 4, 0, 5],
	 [9, 9, 6, 0, 5],
	 [9, 6, 0, 3, 8],
	 [7, 0, 9, 4, 9],
	 [0, 7, 9, 7, 9],
	 [3, 0, 9, 9, 9],
	 [7, 9, 8, 0, 7],
	 [7, 6, 9, 0, 9],
	 [8, 9, 0, 3, 6],
	 [7, 7, 4, 0, 9]]

	In [96]: n
	Out[96]:
	array([0.71739442, 0.9565259 , 1.07609164, 0.87681541, 1.11594688,
	       1.07609164, 1.23551262, 1.27536786, 1.27536786, 0.79710491,
	       0.59782869])

	In [97]: numpy.matmul(n,m)
	Out[97]: array([70.42421924, 65.88072124, 65.20318208, 34.59435332, 80.02933351])


最后结果是 巴厘岛得分最高，所以打算去巴厘岛了。


**后记**::

	我曾经像你一样，打算做一个理智的人。
	用理智的分析来证明我一开始拍脑袋的想法是对的。
	尤其是当事情有点一团乱麻，有眉毛胡子一把抓的窘态时，
	找一个框架，找个理论，来解开九连环。
	选择不是件容易的事，牺牲的机会成本有时很大，我们就会犹疑不决，
	把两件事两两比较的时候，其实就是自问自答，内心一开始的决定就会慢慢显现出来。
	这时候， Follow your heart.









.. feed-entry::
	   :author: Taoge
	   :date: 2018-03-18

